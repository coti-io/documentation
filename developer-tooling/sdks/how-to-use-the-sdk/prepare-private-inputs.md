# Prepare Private Inputs

The gcEVM handles private inputs by encapsulating them within an Inputtext object. To utilize a private input, one must construct an Inputtext instance using their input data.

Each Inputtext instance includes an encrypted representation of the amount and a signature generated by concatenating the sender's address, contract address, function, and the encrypted amount.

The SDK offers a function designed to facilitate the creation of Inputtext objects from the specified data.

The function signature is provided in Python, JavaScript, and Go languages as follows:

{% tabs %}
{% tab title="Python" %}
```python
def prepare_IT(plaintext, user_aes_key, sender, contract, func_sig, signing_key)
```
{% endtab %}

{% tab title="Typescript" %}
```javascript
function prepareIT(plaintext, userAesKey, sender, contract, hashFunc, signingKey)
```
{% endtab %}
{% endtabs %}

The function encrypts the plaintext using the AES key to get the ciphertext, then sign the concatenation of the addresses, hashed function signature and ciphertext using the ECDSA private key.

**Input parameters:**

* plaintext to encrypt
* AES key
* sender address
* contract address
* function signature (as string in go and python case, or hashed in js case)
* ECDSA private key.

**Output:**

* Ciphertext
* Signature

#### Example usage - Private ERC20

When conducting a private amount transfer, the value needs to be converted into an Inputtext format. Below are examples demonstrating how to utilize the prepare IT function in both Python and JavaScript languages:

{% tabs %}
{% tab title="Python" %}
```python
# In order to generate the input text, we need to use some data of the function. 
# For example, the address of the user, the address of the contract and also the function signature.
# To simplify the process of obtaining the function signature, we use a dummy function with placeholder inputs.
# After the signature is generated, we call prepare input text function and get the input text to use in the real function.
dummyCT = 0
dummySignature = bytes(65)
function = contract.functions.transfer(alice_address.address, dummyCT, dummySignature, False)
func_sig = get_function_signature(function.abi) # Get the function signature
# Prepare the input text for the function
ct, signature = prepare_IT(plaintext_integer, user_key, account, contract, func_sig, bytes.fromhex(private_key[2:]))
# Create the real function using the prepared IT
function = contract.functions.transfer(alice_address.address, ct, signature, False)
```
{% endtab %}

{% tab title="Typescript" %}
```javascript
// In order to generate the input text, we need to use some data of the function. 
// For example, the address of the user, the address of the contract and also the function signature.
// To simplify the process of obtaining the function signature, we use a dummy function with placeholder inputs.
// After the signature is generated, we call prepare input text function and get the input text to use in the real function.
const dummyCT = 0;
const dummySignature = Buffer.alloc(65);
func = contract.methods.transfer(alice_address.address, dummyCT, dummySignature, false); // Create dummy function to get the signature for prepare input text
let hashFuncSig = getFunctionSignature(func);
// After the function signature is obtained, prepare the input test for the function
let {ctInt, signature} = prepareIT(plaintext_integer, user_key, account.address, contract.options.address, hashFuncSig, Buffer.from(SIGNING_KEY.slice(2), 'hex'));
// Create the real function using the prepared IT
func = contract.methods.transfer(alice_address.address, ctInt, signature, false);
```
{% endtab %}
{% endtabs %}
